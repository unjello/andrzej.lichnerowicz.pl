<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="og:title" content="Solving AoC in LEAN | @unjello" />
    <meta property="twitter:title" content="Solving AoC in LEAN | @unjello" />
    <meta property="og:url" content="http://andrzej.lichnerowicz.pl/en/blog/solving-aoc-in-lean/" />
    <meta property="og:type" content="blog" />
     
    <meta property="og:image" content="http://andrzej.lichnerowicz.pl/en/blog/solving-aoc-in-lean/lean-emacs.png" />
    <meta property="twitter:image" content="http://andrzej.lichnerowicz.pl/en/blog/solving-aoc-in-lean/lean-emacs.png" />
     
    <meta property="og:description" content="Let&#39;s implement 2024/day/5 Advent of Code puzzle in Lean. BabelOfCode is low key. The goal is to solve each Advent of Code puzzle in a different language." />
    <meta property="twitter:description" content="Let&#39;s implement 2024/day/5 Advent of Code puzzle in Lean. BabelOfCode is low key. The goal is to solve each Advent of Code puzzle in a different language." />
    
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/favicon.ico" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
      crossorigin="anonymous"
    />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.7/purify.min.js"
      integrity="sha512-BdRNuI8/lsyxkKQVxK1lVtfZshggfXPAwEP+JAOJEKx6Y8SLfcBSRdaWyXQmMxo+wG180uFqXYGjGRL0mh4/Jw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

     
    <link
      rel="stylesheet"
      href="/css/style.min.1383b2b88f11c77e52dfaac1bb207e0ad22fa43fc6667da8d1fcf0a06223f40a.css"
      integrity="sha256-E4OyuI8Rx35S36rBuyB&#43;CtIvpD/GZn2o0fzwoGIj9Ao="
      crossorigin="anonymous"
    />
     
    <title>Solving AoC in LEAN | Blog @unjello</title>
  </head>
  <body>
    <canvas
      id="decay-canvas"
      width="3172"
      height="440"
      style="height: 220px; width: 1586px"
    ></canvas>
    <div class="layout container-fluid">
      <header>
        <h1>
          <a href="/">Andrzej unjello Lichnerowicz</a>
        </h1>
        <ul class="list-inline tagline">
          
          <li class="list-inline-item">he</li>
          
          <li class="list-inline-item">him</li>
          
          <li class="list-inline-item">activist</li>
          
          <li class="list-inline-item">trees and greenery lover</li>
          
        </ul>
        <ul class="list-inline socialmedia">
          
          <li class="list-inline-item">
            <a href="https://mastodon.gamedev.place/@unjello">mastodon</a>
          </li>
          
          <li class="list-inline-item">
            <a href="https://codeberg.org/unjello">codeberg</a>
          </li>
          
          <li class="list-inline-item">
            <a href="mailto:andrzej@lichnerowicz.pl">email</a>
          </li>
          
          <li class="list-inline-item">
            <a href="https://andrzej.lichnerowicz.pl/public.pgp">pgp</a>
          </li>
          
        </ul>
      </header>

      <section class="blog_single">
        <h1>Solving AoC in LEAN</h1>
        <div class="date">2025-02-11T19:45:11&#43;02:00</div>
        <div class="content">
          <h1 id="prerequisites">Prerequisites</h1>
<ul>
<li><a href="https://github.com/leanprover-community/lean4-mode">Emacs Major Mode</a> — there are also extensions for <a href="https://github.com/Julian/lean.nvim">Neovim</a> and <a href="https://marketplace.visualstudio.com/items?itemName=leanprover.lean4">VS Code</a>.</li>
<li><a href="https://lean-lang.org/functional_programming_in_lean/title.html">Functional Programming in Lean</a></li>
<li><a href="https://lean-lang.org/doc/reference/latest/">The Lean Language Reference</a></li>
<li><a href="https://leanprover.zulipchat.com">Zulip Forum?</a></li>
</ul>
<h1 id="installation">Installation</h1>
<p>It&rsquo;s fairly straightforward, but you need to be careful with package names. In Homebrew, <code>brew install lean</code> points to the old Lean 3 package. What you actually want now is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fish" data-lang="fish"><span style="display:flex;"><span>❯ brew install elan
</span></span></code></pre></div><p>Similarly, for the Emacs extension, Doom Emacs already includes Lean in its init.el (just uncomment the lean line):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span> lean              <span style="color:#75715e">; for folks with too much to prove</span>
</span></span></code></pre></div><p>However, you will encounter this error:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> &gt; Regenerating envvars file
</span></span><span style="display:flex;"><span>    ✓ Generated ~/.config/emacs/.local/env
</span></span><span style="display:flex;"><span>  x There was an unexpected runtime error
</span></span><span style="display:flex;"><span>    Message: Could not find package company-lean. Updating recipe repositories: 
</span></span><span style="display:flex;"><span>    (org-elpa melpa nongnu-elpa gnu-elpa-mirror el-get emacsmirror-mirror) with 
</span></span><span style="display:flex;"><span>    ‘straight-pull-recipe-repositories’ may fix this
</span></span></code></pre></div><p>It turns out <code>company-lean</code> was removed from MELPA a few months ago. Upgrading <code>doom</code> fixed the original error for me but led to a new one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>lean get info: (json-readtable-error 108).
</span></span></code></pre></div><p>Digging into an issue from <a href="https://leanprover-community.github.io/archive/stream/270676-lean4/topic/Doom.20Emacs.20setup.html#234168724">2023</a>, I found a solution. I removed <code>lean</code> from my <code>init.el</code> and installed the Lean 4 mode manually:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(package! lean4-mode <span style="color:#e6db74">:recipe</span>
</span></span><span style="display:flex;"><span>  (<span style="color:#e6db74">:host</span> github
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">:repo</span> <span style="color:#e6db74">&#34;leanprover/lean4-mode&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">:files</span> (<span style="color:#e6db74">&#34;*.el&#34;</span> <span style="color:#e6db74">&#34;data&#34;</span>)))
</span></span></code></pre></div><h1 id="jump-to-solution">Jump to solution</h1>
<p>To begin, I tried a basic snippet from the Lean docs to read a file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def main (args : List String) : IO Unit := do
</span></span><span style="display:flex;"><span>  match args with
</span></span><span style="display:flex;"><span>  | [] =&gt;
</span></span><span style="display:flex;"><span>    IO.println &#34;Usage: please provide the filename as an argument.&#34;
</span></span><span style="display:flex;"><span>  | filename :: _ =&gt;
</span></span><span style="display:flex;"><span>    let content ← IO.FS.readFile filename
</span></span><span style="display:flex;"><span>    IO.println content
</span></span></code></pre></div><p>That worked, but I wanted to read the file line by line. I went digging through <code>IO.FS</code> and discovered <a href="https://lean-lang.org/doc/reference/latest//IO/Files___-File-Handles___-and-Streams/#IO___FS___Handle___getLine">IO.FS.getLine</a>. It turns out it’s basically an <a href="https://github.com/leanprover/lean4/blob/master/src/Init/System/IO.lean#L429C1-L434C84">FFI</a> call under the hood, which reads until a line break and returns an empty string on EOF. The details are burried in the Lean 4 source code:</p>
<p>Soon, however, I realized Lean’s syntax has some peculiarities, and I needed to go back to the language reference. My attempts at writing a recursive function with do blocks were failing because I hadn’t fully absorbed how Lean’s do syntax actually works.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>/--
</span></span><span style="display:flex;"><span>Read text up to (including) the next line break from the handle.
</span></span><span style="display:flex;"><span>If the returned string is empty, an end-of-file marker has been reached.
</span></span><span style="display:flex;"><span>Note that EOF does not actually close a handle, so further reads may block and return more data.
</span></span><span style="display:flex;"><span>-/
</span></span><span style="display:flex;"><span>@[extern &#34;lean_io_prim_handle_get_line&#34;] opaque getLine (h : @&amp; Handle) : IO String
</span></span></code></pre></div><p>From there, I realized that Lean’s syntax can feel unfamiliar if you’re not fully used to it. I kept stumbling over small details, and I began to suspect I was missing fundamental knowledge about Lean. The tipping point was when I tried something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def processFile (filename: String) : IO Unit := do
</span></span><span style="display:flex;"><span>    let content ← IO.FS.lines filename
</span></span><span style="display:flex;"><span>    let rec processGraph (lines: Array String) (index Nat): IO Unit := do
</span></span><span style="display:flex;"><span>      match index with
</span></span><span style="display:flex;"><span>      | Nat.zero =&gt; return
</span></span><span style="display:flex;"><span>      | idx =&gt; do
</span></span><span style="display:flex;"><span>          IO.println s!&#34;Line does not contain |: {line}; returning&#34;
</span></span><span style="display:flex;"><span>          process_graph lines (idx - 1)
</span></span><span style="display:flex;"><span>    processGraph content content.size
</span></span><span style="display:flex;"><span>    return
</span></span></code></pre></div><p>This code snippet threw errors on <code>Nat.zero</code> and also on <code>processGraph content content.size</code>. I will later discover why, but it turns out <code>do</code> is not just <em>line up instructions in imperative style</em> and using recursion with it can be tricky unless you get the function signatures and scoping exactly right. At that point, it became impossible to keep sweeping my confusion under the rug: I really needed to read the language reference properly, at least the relevant chapters. (I skimmed four entire chapters of the Lean manual to rush into this solution)</p>
<h1 id="back-to-lean-basics">Back to Lean Basics</h1>
<p>So, I got humble and restarted from the ground up, going through basic Lean examples:</p>


<div class="figure-wrapper">
<div class="figure">
  <figure>
  <img src="lean-emacs.png" alt="Screenshot of Emacs with Lean and Lean info sidebar"/>
  </figure>
  <div class="caption">
    <p>LƎⱯN in Emacs</p>
    <p class="photo-attribution">Screenshot by author.</p>
  </div>
</div></div>


<p>One fascinating aspect is that functions can behave like methods if you place them within the namespace of the type. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def String.x (_: String) :=
</span></span><span style="display:flex;"><span>  10
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval &#34;test&#34;.x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-- 10
</span></span></code></pre></div><p>This returns 10. So you can extend a type in Lean by creating a function in the String namespace.</p>
<p>Polymorphism in Lean also reminds me a lot of Zig. Generics take a type parameter, which is a first-class citizen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>structure Point (α : Type) where
</span></span><span style="display:flex;"><span>  x : α
</span></span><span style="display:flex;"><span>  y : α
</span></span><span style="display:flex;"><span>deriving Repr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval ({ x := Nat.zero, y := Nat.zero } : Point Nat)
</span></span></code></pre></div><p>In Lean, functions are <em>curried</em> by default, meaning a function with multiple arguments conceptually becomes a chain of one-argument functions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def replace (α : Type) (point : Point α) (xx : α) (yy : α) : Point α :=
</span></span><span style="display:flex;"><span>  { point with x := xx, y := yy }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#check (replace)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>replace : (α : Type) → Point α → α → α → Point α
</span></span></code></pre></div>
<div class="admonition tip">
    <p class="title"></p>
    <p class="content">Currying was named after an american mathematician, logician and computer scientist - <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Brooks Curry</a></p>
</div>

<p>You can see it’s not just <code>(α, point, xx, yy)</code> in a single call, but actually <code>(α) → (point) → (xx) → (yy)</code>. If you partially apply it &ndash; say, omit the last parameter &ndash; you get back a function waiting on that parameter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def add (a : Nat) (b : Nat) : Nat :=
</span></span><span style="display:flex;"><span>  a + b
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval add 10
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-- Could not synthetize a &#39;Repr&#39; or &#39;ToString&#39; instance of type
</span></span><span style="display:flex;"><span>-- Nat → Nat 
</span></span></code></pre></div><p>Another awesome feature is that Lean treats types as first-class citizens. You can do things like write a function that returns different types based on an inductive constructor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>inductive Sign where
</span></span><span style="display:flex;"><span>  | pos
</span></span><span style="display:flex;"><span>  | neg
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def direction (s : Sign) : match s with | Sign.pos =&gt; Nat | Sign.neg =&gt; Int :=
</span></span><span style="display:flex;"><span>  match s with
</span></span><span style="display:flex;"><span>  | Sign.pos =&gt; (1 : Nat)
</span></span><span style="display:flex;"><span>  | Sign.neg =&gt; (-1 : Int)
</span></span></code></pre></div><p>To me, that’s pretty mind-blowing. This kind of type-level computation is powerful and elegantly integrated.</p>
<p>Another thing to notice is that <em>pairs</em> in Lean are <code>Prods</code>, while <code>Sum</code> is akin to <code>std::variant</code> in C++, so you have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def sevens : String × (Int × Nat) := (&#34;VII&#34;, (7, 4 + 3)) - para
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def Weird : Type := String ⊕ Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def weird : List Weird :=
</span></span><span style="display:flex;"><span>  [Sum.inl &#34;S&#34;, Sum.inr 10, Sum.inl &#34;F&#34;, Sum.inl &#34;R&#34;, Sum.inr 20]
</span></span></code></pre></div><p>Pattern matching is central to Lean, so to define, say, a function that returns the last element of a list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def List.last {α : Type} (xs : List α) : Option α :=
</span></span><span style="display:flex;"><span>  match list with
</span></span><span style="display:flex;"><span>   | [] =&gt; none
</span></span><span style="display:flex;"><span>   | x :: [] =&gt; some x
</span></span><span style="display:flex;"><span>   | _ :: rest =&gt; last rest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval [1, 2, 3].last
</span></span></code></pre></div><p>Or to find the first element matching a predicate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def List.findFirst {α : Type} (xs : List α) (predicate : α -&gt; Bool) : Option α :=
</span></span><span style="display:flex;"><span>  match xs with
</span></span><span style="display:flex;"><span>  | [] =&gt; none
</span></span><span style="display:flex;"><span>  | x :: rest =&gt; if predicate x then some x else List.findFirst rest predicate
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def is2 (x : Nat) : Bool :=
</span></span><span style="display:flex;"><span>  match x with
</span></span><span style="display:flex;"><span>  | 2 =&gt; true
</span></span><span style="display:flex;"><span>  | _ =&gt; false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval [1, 2, 3].findFirst is2
</span></span></code></pre></div><p>Pattern matching is so central to Lean that there is a dedicated shortcut for the most common scenario: when your first line of code matches on the function parameter. As a result, the example shown above can be rewritten as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def List.findFirst : List α → (α → Bool) → Option α
</span></span><span style="display:flex;"><span>| [], _ =&gt; none
</span></span><span style="display:flex;"><span>| x :: rest, pred =&gt; if pred x then some x else List.findFirst rest pred
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def is2 : Nat → Bool
</span></span><span style="display:flex;"><span>| 2 =&gt; true
</span></span><span style="display:flex;"><span>| _ =&gt; false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval [1, 2, 3].findFirst is2
</span></span></code></pre></div><p>Lean also has couple more interesting tricks like <em>simulatnous matching</em>, which is matching a pattern of many variables at once. Lean also can deduce most of the types for us, and sometimes defining a type is completly unnecessary. Combine that with anonymous functions and you can rewrite the above as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def List.findFirst : List α → (α → Bool) → Option α
</span></span><span style="display:flex;"><span>| [], _ =&gt; none
</span></span><span style="display:flex;"><span>| x :: rest, pred =&gt; if pred x then some x else List.findFirst rest pred
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval [1, 2, 3].findFirst (· = 2)
</span></span></code></pre></div><p>Or shorten the predicate to <code>(· = 2)</code>, which is the same as <code>fun x =&gt; x = 2</code>. You’ll also see a lot of Unicode in Lean code (<code>α</code>, <code>β</code>, <code>→</code>, etc.). Emacs Lean mode provides a long list of <a href="https://github.com/leanprover-community/lean4-mode/blob/master/data/abbreviations.json">very handy shortcuts</a> (e.g., <code>\r</code> → <code>→</code>, <code>\.</code> → <code>·</code>, etc.) that make it straightforward to type these symbols.</p>
<p>Finally, there’s Lean’s <code>do</code> notation. This is not just <em>an imperative style</em>, but more accurately a domain-specific language for monadic composition. If you’re coming from Haskell, it’ll feel familiar. If you’re from an imperative language, the syntax looks welcoming, but the semantics are different—each line returns a result that’s passed along in a monadic context.</p>
<h1 id="the-puzzle">The Puzzle</h1>
<p>Now, enough with the theory: let’s tackle the <a href="https://adventofcode.com/2024/day/5">Advent of Code 2024 Day 5</a> puzzle. The problem deals with a directed graph of page references: <em>Page X must come before Page Y</em>. Then we’re given sequences to check whether the order is valid, and we also need a topological ordering for part two.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def parseLines (lines : List String) : List String :=
</span></span><span style="display:flex;"><span>  match lines with
</span></span><span style="display:flex;"><span>  | [] =&gt; []
</span></span><span style="display:flex;"><span>  | line :: rest =&gt; match line.posOf &#39;|&#39; with
</span></span><span style="display:flex;"><span>    | false =&gt; rest
</span></span><span style="display:flex;"><span>    | true =&gt; parseLines rest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#eval parseLines [&#34;a|r&#34;, &#34;k|a&#34;]
</span></span></code></pre></div><p>Nope :)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Messages below:
</span></span><span style="display:flex;"><span>27:6:
</span></span><span style="display:flex;"><span>type mismatch
</span></span><span style="display:flex;"><span>  false
</span></span><span style="display:flex;"><span>has type
</span></span><span style="display:flex;"><span>  Bool : Type
</span></span><span style="display:flex;"><span>but is expected to have type
</span></span><span style="display:flex;"><span>  String.Pos : Type
</span></span><span style="display:flex;"><span>30:0:
</span></span><span style="display:flex;"><span>aborting evaluation since the expression depends on the &#39;sorry&#39; axiom, which can lead to runtime instability and crashes.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>To attempt to evaluate anyway despite the risks, use the &#39;#eval!&#39; command.
</span></span></code></pre></div><p>That failed because <code>posOf</code> returns a position (a <code>Nat</code>), not a <code>Bool</code>. I also got an error about the <a href="https://github.com/leanprover/lean3/issues/1355">sorry</a> axiom, which Lean uses to stub out missing proofs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>theorem my_theorem : 2 + 2 = 4 :=
</span></span><span style="display:flex;"><span>sorry
</span></span></code></pre></div><p>That’s not relevant for finished code, but it’s interesting to see how Lean explicitly requires proofs for certain conditions like termination or safety. In older Lean versions, <code>#eval</code> could run code with unsolved proofs, but that’s no longer allowed by default.</p>
<p>I refactored my approach after more reading. My new idea was: gather all lines containing <code>|</code>, split them, convert to <code>Nat</code>, and store them in a graph. Something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def parsePageRules (lines : List String) (graph : HashMap Nat (List Nat)) : (List String × HashMap Nat (List Nat)) :=
</span></span><span style="display:flex;"><span>  match lines with
</span></span><span style="display:flex;"><span>  | [] =&gt; ([], graph)
</span></span><span style="display:flex;"><span>  | line :: rest =&gt;
</span></span><span style="display:flex;"><span>    match line.contains &#39;|&#39; with
</span></span><span style="display:flex;"><span>    | false =&gt; (rest, graph)
</span></span><span style="display:flex;"><span>    | true =&gt;
</span></span><span style="display:flex;"><span>      let parts := line.split (· = &#39;|&#39;)
</span></span><span style="display:flex;"><span>      if parts.length != 2 then
</span></span><span style="display:flex;"><span>        (rest, graph)
</span></span><span style="display:flex;"><span>      else
</span></span><span style="display:flex;"><span>        match parts with
</span></span><span style="display:flex;"><span>        | [l, r] =&gt;
</span></span><span style="display:flex;"><span>          match (l.trim.toNat?, r.trim.toNat?) with
</span></span><span style="display:flex;"><span>          | (some left, some right) =&gt;
</span></span><span style="display:flex;"><span>            let successors := graph.getD left []
</span></span><span style="display:flex;"><span>            let graph&#39; := graph.insert left (right :: successors)
</span></span><span style="display:flex;"><span>            parsePageRules rest graph&#39;
</span></span><span style="display:flex;"><span>          | _ =&gt;  (rest, graph)
</span></span><span style="display:flex;"><span>        | _ =&gt; (rest, graph)
</span></span></code></pre></div><p>But to simplify, I ended up deciding to fold over all lines and skip those without <code>|</code>. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def skipToPageRules (lines : List String) :=
</span></span><span style="display:flex;"><span>  match lines with
</span></span><span style="display:flex;"><span>  | [] =&gt; []
</span></span><span style="display:flex;"><span>  | &#34;&#34; :: rest =&gt; rest
</span></span><span style="display:flex;"><span>  | _ :: rest =&gt; skipToPageRules rest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def parsePageRules (lines : List String) :=
</span></span><span style="display:flex;"><span>  lines.foldl (fun arr line =&gt;
</span></span><span style="display:flex;"><span>    if line.contains &#39;|&#39; then
</span></span><span style="display:flex;"><span>      ((line.split (. = &#39;|&#39;)
</span></span><span style="display:flex;"><span>      |&gt;.map (fun x =&gt; x.trim)
</span></span><span style="display:flex;"><span>      |&gt;.map (fun x =&gt; x.toNat!))
</span></span><span style="display:flex;"><span>      :: arr)
</span></span><span style="display:flex;"><span>    else
</span></span><span style="display:flex;"><span>      arr
</span></span><span style="display:flex;"><span>  ) ([] : List (List Nat))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def createRulesGraph (page_rules : List (List Nat)) :=
</span></span><span style="display:flex;"><span>  page_rules.foldl (fun g rule =&gt;
</span></span><span style="display:flex;"><span>    match rule with
</span></span><span style="display:flex;"><span>    | [x, y] =&gt;
</span></span><span style="display:flex;"><span>      let successors := g.getD x []
</span></span><span style="display:flex;"><span>      let g&#39; := g.insert x (y :: successors)
</span></span><span style="display:flex;"><span>      if g&#39;.contains y then g&#39; else g&#39;.insert y []
</span></span><span style="display:flex;"><span>    | _ =&gt; g) (HashMap.empty)
</span></span></code></pre></div><p>Having built the graph, the next step was to check if a page sequence is <em>correctly ordered</em> &ndash; i.e., does each page appear before all of its successors? One straightforward way is to transform your list of pages into an index map (page -&gt; its position), and then verify the condition index(page) &lt; index(successor):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def ordered? (pages : List Nat) (rules : HashMap Nat (List Nat)) :=
</span></span><span style="display:flex;"><span>   let indexMap := pages.enum.foldl (fun m (i, p) =&gt; m.insert p i) (HashMap.empty)
</span></span><span style="display:flex;"><span>   pages.all (fun page =&gt;
</span></span><span style="display:flex;"><span>     let idx := indexMap.getD page 0
</span></span><span style="display:flex;"><span>     let successors := rules.getD page []
</span></span><span style="display:flex;"><span>     successors.all (fun s =&gt;
</span></span><span style="display:flex;"><span>       if indexMap.contains s then
</span></span><span style="display:flex;"><span>         let idxS := indexMap.getD s 0
</span></span><span style="display:flex;"><span>         idx &lt; idxS
</span></span><span style="display:flex;"><span>       else
</span></span><span style="display:flex;"><span>         true
</span></span><span style="display:flex;"><span>     )
</span></span><span style="display:flex;"><span>   )
</span></span></code></pre></div><p>Testing that with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fish" data-lang="fish"><span style="display:flex;"><span>❯ lean <span style="color:#a6e22e">--run</span> day05.lean example.txt
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Part</span> <span style="color:#ae81ff">1</span> Result: <span style="color:#ae81ff">143</span>
</span></span></code></pre></div><p>That worked great. Then for part two, we want a topological sort of the pages:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>def processPages (inDegree : HashMap Nat Nat) (localRulesMap : HashMap Nat (List Nat)) (queue : List Nat) (pages : List Nat)  (sorted : List Nat) :=
</span></span><span style="display:flex;"><span>  match queue with
</span></span><span style="display:flex;"><span>  | [] =&gt; sorted
</span></span><span style="display:flex;"><span>  | el :: _ =&gt;
</span></span><span style="display:flex;"><span>    let sorted&#39; := sorted ++ [el]
</span></span><span style="display:flex;"><span>    let successors := localRulesMap.getD el []
</span></span><span style="display:flex;"><span>    let inDegree&#39; := successors.foldl reduce inDegree
</span></span><span style="display:flex;"><span>    let pages&#39; := pages.erase el
</span></span><span style="display:flex;"><span>    let queue&#39; := pages&#39;.filter (fun p =&gt; inDegree.getD p 0 = 0)
</span></span><span style="display:flex;"><span>    processPages inDegree&#39; localRulesMap queue&#39; pages&#39; sorted&#39;
</span></span></code></pre></div><p>At first, Lean refused to compile, complaining about not being able to prove termination.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>fail to show termination for
</span></span><span style="display:flex;"><span>  processPages
</span></span><span style="display:flex;"><span>with errors
</span></span><span style="display:flex;"><span>failed to infer structural recursion:
</span></span><span style="display:flex;"><span>Cannot use parameter inDegree:
</span></span><span style="display:flex;"><span>  the type HashMap Nat Nat does not have a `.brecOn` recursor
</span></span><span style="display:flex;"><span>Cannot use parameter localRulesMap:
</span></span><span style="display:flex;"><span>  the type HashMap Nat (List Nat) does not have a `.brecOn` recursor
</span></span><span style="display:flex;"><span>Cannot use parameter queue:
</span></span><span style="display:flex;"><span>  failed to eliminate recursive application
</span></span><span style="display:flex;"><span>    processPages inDegree&#39; localRulesMap queue&#39; pages&#39; sorted&#39;
</span></span><span style="display:flex;"><span>Cannot use parameter pages:
</span></span><span style="display:flex;"><span>  failed to eliminate recursive application
</span></span><span style="display:flex;"><span>    processPages inDegree&#39; localRulesMap queue&#39; pages&#39; sorted&#39;
</span></span><span style="display:flex;"><span>Cannot use parameter sorted:
</span></span><span style="display:flex;"><span>  failed to eliminate recursive application
</span></span><span style="display:flex;"><span>    processPages inDegree&#39; localRulesMap queue&#39; pages&#39; sorted&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Could not find a decreasing measure.
</span></span><span style="display:flex;"><span>The arguments relate at each recursive call as follows:
</span></span><span style="display:flex;"><span>(&lt;, ≤, =: relation proved, ? all proofs failed, _: no proof attempted)
</span></span><span style="display:flex;"><span>           queue pages #1
</span></span><span style="display:flex;"><span>1) 95:4-55     ?     ?  ?
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#1: sorted
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Please use `termination_by` to specify a decreasing measure.
</span></span></code></pre></div><p>When Lean compiles a recursive function, it requires a proof that the recursion terminates (unless you mark it partial). My recursion doesn’t obviously shrink just from the function arguments, because I’m mutating a <code>HashMap</code> and scanning a <code>queue</code> in each step. Also, <code>HashMap</code> doesn’t provide a built-in structural measure for the compiler.</p>
<p>I tried messing with <code>termination_by</code> and <code>decreasing_by</code> but got stuck. Then I realized Lean was actually helping me find a logical bug. I used <code>partial def</code> to bypass the termination check and inserted <code>dbg_trace</code> debugging:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>set_option diagnostics true
</span></span><span style="display:flex;"><span>set_option diagnostics.threshold 255
</span></span><span style="display:flex;"><span>partial def processPages (inDegree : HashMap Nat Nat) (localRulesMap : HashMap Nat (List Nat)) (queue : List Nat) (pages : List Nat)  (sorted : List Nat) :=
</span></span><span style="display:flex;"><span>  match queue with
</span></span><span style="display:flex;"><span>  | [] =&gt; sorted
</span></span><span style="display:flex;"><span>  | el :: _ =&gt;
</span></span><span style="display:flex;"><span>    let sorted&#39; := sorted ++ [el]
</span></span><span style="display:flex;"><span>    let successors := localRulesMap.getD el []
</span></span><span style="display:flex;"><span>    let inDegree&#39; := successors.foldl reduce inDegree
</span></span><span style="display:flex;"><span>    let pages&#39; := pages.erase el
</span></span><span style="display:flex;"><span>    let queue&#39; := pages&#39;.filter (fun p =&gt; inDegree.getD p 0 = 0)
</span></span><span style="display:flex;"><span>    dbg_trace s!&#34;pages={pages&#39;}, queue={queue&#39;}&#34;
</span></span><span style="display:flex;"><span>    processPages inDegree&#39; localRulesMap queue&#39; pages&#39; sorted&#39;
</span></span></code></pre></div><p>It turned out I was filtering the queue with the old <code>inDegree</code> instead of <code>inDegree'</code>. Correcting that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>let queue&#39; := pages&#39;.filter (fun p =&gt; inDegree&#39;.getD p 0 = 0)
</span></span></code></pre></div><p>solved my logical error. And indeed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fish" data-lang="fish"><span style="display:flex;"><span>❯ lean <span style="color:#a6e22e">--run</span> day05.lean input.txt
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Part</span> <span style="color:#ae81ff">1</span> Result: <span style="color:#ae81ff">143</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Part</span> <span style="color:#ae81ff">2</span> Result: <span style="color:#ae81ff">123</span>
</span></span></code></pre></div><p>Victory! Lean’s termination system was right to be suspicious. After I fixed the bug, I could have tried again to provide a proper termination metric, but partial was enough for my immediate puzzle solution.</p>
<p>With that, I cleaned up and pushed everything to <a href="http://codeberg.org/unjello/babel-of-code/src/branch/main/2025/05">Codeberg</a>.</p>
<p>Next week, I’m solving another Advent of Code puzzle in <a href="https://fishshell.com">fish</a> to learn how it differs from Bash. See you later!</p>
 
          <div class="comments">
            <h2>Comments</h2>
            <p>
              Discussion powered by <i class="fa-brands fa-mastodon"></i>,
              <a href="https://mastodon.gamedev.place/@unjello/113986745716326625"
                >hop in.</a
              >
              if you want.
            </p>
            <div id="comments"></div>
          </div>
          <script>
            (async function () {
              const commentsDiv = document.getElementById("comments");
              const statusId = "113986745716326625";
              const mastodonInstance = "mastodon.gamedev.place";
              const contextUrl = `https://${mastodonInstance}/api/v1/statuses/${statusId}/context`;

              try {
                const response = await fetch(contextUrl);

                if (!response.ok) {
                  throw new Error(
                    "Network response was not ok " + response.statusText,
                  );
                }

                const context = await response.json();
                const comments = context.descendants;
                comments.forEach((comment) => {
                  const commentElement = document.createElement("div");
                  commentElement.classList.add("comment");

                  const authorName = DOMPurify.sanitize(
                    comment.account.display_name || comment.account.username,
                  );
                  const authorUrl = DOMPurify.sanitize(comment.account.url);
                  const content = DOMPurify.sanitize(comment.content);
                  const avatarUrl = DOMPurify.sanitize(
                    comment.account.avatar_static || comment.account.avatar,
                  );
                  const createdAt = new Date(comment.created_at);
                  const timestamp = createdAt.toLocaleString();

                  const avatarImg = document.createElement("img");
                  avatarImg.src = avatarUrl;
                  avatarImg.alt = `${authorName}'s avatar`;
                  avatarImg.classList.add("avatar");

                  const contentDiv = document.createElement("div");
                  contentDiv.classList.add("comment-content");

                  const headerDiv = document.createElement("div");
                  headerDiv.classList.add("comment-header");

                  const authorLink = document.createElement("a");
                  authorLink.href = authorUrl;
                  authorLink.target = "_blank";
                  authorLink.textContent = authorName;

                  const timeSpan = document.createElement("span");
                  timeSpan.classList.add("timestamp");
                  timeSpan.textContent = `• ${timestamp}`;

                  headerDiv.appendChild(authorLink);
                  headerDiv.appendChild(timeSpan);

                  const bodyDiv = document.createElement("div");
                  bodyDiv.classList.add("comment-body");
                  bodyDiv.innerHTML = content;

                  contentDiv.appendChild(headerDiv);
                  contentDiv.appendChild(bodyDiv);

                  commentElement.appendChild(avatarImg);
                  commentElement.appendChild(contentDiv);

                  commentsDiv.appendChild(commentElement);
                });
              } catch (error) {
                console.error("Error fetching comments:", error);
                commentsDiv.innerHTML = "<p>Error loading comments.</p>";
              }
            })();
          </script>
          
        </div>
      </section>
      <script>
        
        (function addTitleToCodeBlock() {
          let list = document.body.getElementsByClassName("highlight");

          for (i = 0; i <= list.length - 1; i++) {
            let code = list[i].firstElementChild.firstElementChild;
            let codeName = code ? code.className.split(":")[1] : null;

            if (codeName) {
              console.log(codeName);
              let div = document.createElement("div");
              div.textContent = codeName;
              div.classList.add("code-name");
              code.parentNode.insertBefore(div, code);
            }
          }
        })();
      </script>

      <footer class="fs-6 text-muted mt-5">
        <p>
          CC0. Powered by <a href="https://gohugo.io">Hugo</a>. Theme inspired
          by <a href="https://www.mattdesl.com/">@mattdesl</a> and
          <a href="https://ozafoto.com/digital/">Oza</a>.
        </p>
      </footer>
    </div>
  </body>
  <script type="text/javascript">
    

    function decay() {
      const canvas = document.getElementById("decay-canvas");
      const pixelSize = window.innerWidth > 1600 ? 8 : 6;

      canvas.width = window.innerWidth * 2;
      canvas.height = 440;
      canvas.style.height = canvas.height / 2 + "px";
      canvas.style.width = canvas.width / 2 + "px";
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#fff";
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let j = 0; j < canvas.height; j += pixelSize) {
        const probability = Math.pow(
          (canvas.height - 1 - j) / (canvas.height - 1),
          3,
        );
        for (let i = 0; i < canvas.width; i += pixelSize) {
          if (Math.random() < probability) {
            ctx.fillRect(i, j, pixelSize, pixelSize);
          }
        }
      }
    }

    window.isReducedMotion = () =>
      window.matchMedia(`(prefers-reduced-motion: reduce)`) === true ||
      window.matchMedia(`(prefers-reduced-motion: reduce)`).matches === true;

    window.onload = () => {
      if (!isReducedMotion()) {
        decay();
      }

      document.addEventListener("resize", () => {
        if (!isReducedMotion()) {
          decay();
        }
      });

      document.addEventListener("scroll", () => {
        if (!isReducedMotion()) {
          decay();
        }
      });
    };
  </script>
</html>
