<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="twitter:card" content="summary_large_image">
    <meta property="og:title" content="Rust Macros: A Cautionary Tale | @unjello" />
    <meta property="twitter:title" content="Rust Macros: A Cautionary Tale | @unjello">
    <meta property="og:url" content="http://andrzej.lichnerowicz.pl/en/blog/rust-macros-a-cautionary-tale/" />
    <meta property="og:type" content="blog" />
    
    
    
    <meta property="og:description" content="A short story of how I went down the rust macros rabbit hole." />
    <meta property="twitter:description" content="A short story of how I went down the rust macros rabbit hole.">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="apple-touch-icon" href="/favicon.ico">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.7/purify.min.js" integrity="sha512-BdRNuI8/lsyxkKQVxK1lVtfZshggfXPAwEP+JAOJEKx6Y8SLfcBSRdaWyXQmMxo+wG180uFqXYGjGRL0mh4/Jw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    
    
      <link rel="stylesheet" href="/css/style.min.2e859e4992bcd5ecfc1a48111216f98958cd0696c0278c0e2513e50ee64ead0d.css" integrity="sha256-LoWeSZK81ez8GkgREhb5iVjNBpbAJ4wOJRPlDuZOrQ0=" crossorigin="anonymous">
    
    
    <title>Rust Macros: A Cautionary Tale | Blog @unjello</title>
  </head>
  <body>
    <div class="layout container-fluid">
        <header>
            <h1>
                <a href="/">Andrzej unjello Lichnerowicz</a>
            </h1>
            <ul class="list-inline tagline">
                
                    <li class="list-inline-item">he</li>
                
                    <li class="list-inline-item">him</li>
                
                    <li class="list-inline-item">activist</li>
                
                    <li class="list-inline-item">trees and greenery lover</li>
                
            </ul>
            <ul class="list-inline socialmedia">
                
                    <li class="list-inline-item">
                        <a href="https://mastodon.gamedev.place/@unjello">mastodon</a>
                    </li>                            
                
                    <li class="list-inline-item">
                        <a href="https://codeberg.org/unjello">codeberg</a>
                    </li>                            
                
                    <li class="list-inline-item">
                        <a href="mailto:andrzej@lichnerowicz.pl">email</a>
                    </li>                            
                
            </ul>
        </header>

        <section class="blog_single">
            <h1>Rust Macros: A Cautionary Tale</h1>
            <div class="date">2024-11-09T18:41:15&#43;02:00</div>
            <div class="content">
                <p>I pitched the idea of rewriting one of the Kubernetes services I work with in Rust, and I got the green light. Long story short, I’ve been writing a lot of Rust lately. It’s obviously not Zig (&lt;3), but it’s way better than some alternatives :)</p>
<p>One of the trickiest parts of Rust &ndash; even for experienced Rustaceans &ndash; is definitely the macro system. So, how did I find myself neck-deep in Rust macros? I was building a tool that needed to communicate with a few internal services, each with its own client connection pattern. The goal was to create multiple clients that followed a similar structure: connect to a service and fetch data. This seemed like a perfect use case for a <code>Trait</code>.</p>
<p>But here’s the catch: each service had its own connection requirements. Some used <a href="https://datatracker.ietf.org/doc/html/rfc7617">Basic Auth</a>, others relied on <a href="https://datatracker.ietf.org/doc/html/rfc6750">Bearer Tokens</a>, and a few needed full <a href="https://datatracker.ietf.org/doc/html/rfc6749">OAuth Authorization</a>. Some required a username and password, some wanted a token and username, and others just needed a token. It was a bit all over the place. This felt like the ideal situation for the <a href="https://en.wikipedia.org/wiki/Builder_pattern">builder pattern</a> set up each client with a builder, and then interact with them through a <code>Trait</code>.</p>
<p>My initial drafts, though, were repetitive and clunky. The solution? Macros!</p>
<h2 id="overview-of-existing-crates">Overview of Existing Crates</h2>
<p>First, I looked for crates I could reuse. There’s an excellent and popular crate, <a href="https://crates.io/crates/derive_builder">derive_builder</a>, and another one, <a href="https://crates.io/crates/builder_macro">builder_macro</a>. Unfortunately, neither of them did exactly what I had in mind. I wanted a feature where if I defined a field as an <code>Option</code> in my struct, it would be optional. This might be a questionable pattern, but I wanted to defer calculating certain default values until later.</p>
<p>At first glance, <code>derive_builder</code> looked perfect because it has a setting to strip the <code>Option</code> from fields:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> derive_builder::Builder;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Builder, Default, Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[builder(setter(strip_option))]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Client</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> required: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> optional: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> ClientBuilder::default()
</span></span><span style="display:flex;"><span>        .required(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        .build()
</span></span><span style="display:flex;"><span>        .unwrap();
</span></span><span style="display:flex;"><span>    print!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{:?}</span><span style="color:#e6db74">&#34;</span>, client);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But when I looked at the generated code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">build</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>) -&gt; ::derive_builder::export::core::result::Result<span style="color:#f92672">&lt;</span>Client, ClientBuilderError<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    Ok(Client {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// [...]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        optional: <span style="color:#a6e22e">match</span> self.optional {
</span></span><span style="display:flex;"><span>            Some(<span style="color:#66d9ef">ref</span> value) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                ::derive_builder::export::core::clone::Clone::clone(value)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> ::derive_builder::export::core::result::Result::Err(
</span></span><span style="display:flex;"><span>                    ::derive_builder::export::core::convert::Into::into(
</span></span><span style="display:flex;"><span>                        ::derive_builder::UninitializedFieldError::from(<span style="color:#e6db74">&#34;optional&#34;</span>),
</span></span><span style="display:flex;"><span>                    ),
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It turns out that stripping the Option makes the field required, which was not what I wanted at all. The other crate, <a href="https://crates.io/crates/derive_builder">builder_macro</a>, also didn’t work for me; it kept <code>Option</code> in the setters, creating code like <code>.with_optional(Some(true))</code>, which felt messy. So, of course, I thought, “I should write a macro to automate this!”</p>
<p><img alt="I should write a program automating it!" src="/en/blog/rust-macros-a-cautionary-tale/automation_2x.png"></p>
<h1 id="type-alias-and-struct-limitations-in-macros">Type Alias and Struct Limitations in Macros</h1>
<p>One of the things I initially hoped was that Rust might allow me to use macros to return a type, something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Builder</span> <span style="color:#f92672">=</span> builder!({
</span></span><span style="display:flex;"><span>    example: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>Unfortunately, as described in <a href="https://doc.rust-lang.org/reference/items/type-aliases.html">The Rust Reference</a>, type aliases can only create new names for existing types within the scope they are defined, so they can’t represent a local struct within a macro. This also means we can’t use a type alias to reference the struct in a way that allows direct initialization, like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> Builder();
</span></span></code></pre></div><p>Rust doesn’t support defining new types (structs or otherwise) inline within macros, which limits how we can structure things. While this isn’t a huge problem, it’s something to keep in mind while designing complex macro patterns.</p>
<h1 id="macro-by-example">Macro-by-Example</h1>
<p>My first approach was pretty direct…and it failed spectacularly. So I took a step back and actually read through the documentation—the excellent <a href="https://veykril.github.io/tlborm/introduction.html">The Little Book of Rust Macros</a>. If you read it carefully, it explains everything you need to know, though without prior experience (and failures), it’s easy to overlook details.</p>
<p>Here’s what my first attempt looked like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>macro_rules<span style="color:#f92672">!</span> builder {
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_type Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span><span style="color:#f92672">&gt;</span>) <span style="color:#f92672">=&gt;</span> { Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span><span style="color:#f92672">&gt;</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_type <span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span>) <span style="color:#f92672">=&gt;</span> { Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span><span style="color:#f92672">&gt;</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#75715e">$builder</span>:<span style="color:#a6e22e">ident</span> -&gt; <span style="color:#75715e">$client</span>:<span style="color:#a6e22e">ident</span> { <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>:<span style="color:#a6e22e">ident</span>: <span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span><span style="color:#f92672">+</span> <span style="color:#75715e">$(,</span>)<span style="color:#f92672">?</span> )<span style="color:#f92672">*</span> }) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#75715e">$client</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>, )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#75715e">$builder</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$crate</span>::builder!(<span style="color:#f92672">@</span>builder_field_type <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>), )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>builder!(Builder -&gt; <span style="color:#a6e22e">Client</span> {
</span></span><span style="display:flex;"><span>    example: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    other: String
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>This approach uses a neat trick called <a href="https://veykril.github.io/tlborm/decl-macros/patterns/internal-rules.html">Internal Rules</a>, which allows calling a macro within itself without polluting the global namespace. It also features a <code>Builder -&gt; Client</code> syntax I borrowed from <a href="https://crates.io/crates/builder_macr"><code>builder_macro</code></a>. I liked this syntax because it was a good compromise between readability and macro hygiene.</p>
<p>Unfortunately, it didn’t work. Rust treats matched macro patterns like <code>ty</code> as opaque, meaning once they’re matched, they can’t be broken down further. So instead of <code>$fname:ty</code>, we’d need to use <code>$($fname:tt)+</code>, but then our expression would become greedy and capture tokens incorrectly. The solution? Use <code>[]</code>, <code>{}</code>, or <code>()</code> as a natural boundary, like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>macro_rules<span style="color:#f92672">!</span> builder {
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_type Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span><span style="color:#f92672">&gt;</span>) <span style="color:#f92672">=&gt;</span> { Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span><span style="color:#f92672">&gt;</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_type <span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span>) <span style="color:#f92672">=&gt;</span> { Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span><span style="color:#f92672">&gt;</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#75715e">$builder</span>:<span style="color:#a6e22e">ident</span> -&gt; <span style="color:#75715e">$client</span>:<span style="color:#a6e22e">ident</span> { <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>:<span style="color:#a6e22e">ident</span>{<span style="color:#75715e">$($ftype</span>:<span style="color:#a6e22e">tt</span>)<span style="color:#f92672">+</span>} <span style="color:#75715e">$(,</span>)<span style="color:#f92672">?</span> )<span style="color:#f92672">*</span> }) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#75715e">$client</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>, )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#75715e">$builder</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$crate</span>::builder!(<span style="color:#f92672">@</span>builder_field_type <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>), )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>builder!(Builder -&gt; <span style="color:#a6e22e">Client</span>{
</span></span><span style="display:flex;"><span>  example{<span style="color:#66d9ef">bool</span>},
</span></span><span style="display:flex;"><span>  other{Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>}
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>Here, I used <code>{}</code> as a delimiter because it resembles C++11 initializer syntax.</p>
<p>The next hurdle was generating methods like <code>with_example</code> from field named <code>example</code>. Rust macros don’t allow identifier concatenation, and <code>concat_idents</code>, available in nightly, <a href="https://doc.rust-lang.org/std/macro.concat_idents.html">doesn’t allow function definitions</a>. Thankfully, there’s a crate called <a href="https://crates.io/crates/paste">paste</a> that can handle this. The final result was satisfying:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>macro_rules<span style="color:#f92672">!</span> builder {
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_type Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span><span style="color:#f92672">&gt;</span>) <span style="color:#f92672">=&gt;</span> { Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span><span style="color:#f92672">&gt;</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_type <span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span>) <span style="color:#f92672">=&gt;</span> { Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span><span style="color:#f92672">&gt;</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_setter_type Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span><span style="color:#f92672">&gt;</span>) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">$ftype</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_field_setter_type <span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span>) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">$ftype</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_unwrap_field <span style="color:#75715e">$self</span>:<span style="color:#a6e22e">ident</span> <span style="color:#75715e">$fname</span>:<span style="color:#a6e22e">ident</span> Option<span style="color:#f92672">&lt;</span><span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span><span style="color:#f92672">&gt;</span>) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">$self</span>.<span style="color:#75715e">$fname</span>.clone() };
</span></span><span style="display:flex;"><span>    (<span style="color:#f92672">@</span>builder_unwrap_field <span style="color:#75715e">$self</span>:<span style="color:#a6e22e">ident</span> <span style="color:#75715e">$fname</span>:<span style="color:#a6e22e">ident</span> <span style="color:#75715e">$ftype</span>:<span style="color:#a6e22e">ty</span>) <span style="color:#f92672">=&gt;</span> { <span style="color:#75715e">$self</span>.<span style="color:#75715e">$fname</span>.clone().ok_or_else(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Field &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39; is required&#34;</span>, stringify!(<span style="color:#75715e">$fname</span>)))<span style="color:#f92672">?</span> };
</span></span><span style="display:flex;"><span>    (<span style="color:#75715e">$builder</span>:<span style="color:#a6e22e">ident</span> -&gt; <span style="color:#75715e">$client</span>:<span style="color:#a6e22e">ident</span> { <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>:<span style="color:#a6e22e">ident</span>{<span style="color:#75715e">$($ftype</span>:<span style="color:#a6e22e">tt</span>)<span style="color:#f92672">+</span>} <span style="color:#75715e">$(,</span>)<span style="color:#f92672">?</span> )<span style="color:#f92672">*</span> }) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#75715e">$client</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>, )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#75715e">$builder</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$crate</span>::builder!(<span style="color:#f92672">@</span>builder_field_type <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>), )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span> <span style="color:#75715e">$builder</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">$(</span>
</span></span><span style="display:flex;"><span>                paste::paste! {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> [<span style="color:#f92672">&lt;</span>with_ <span style="color:#75715e">$fname</span><span style="color:#f92672">&gt;</span>](<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$crate</span>::builder!(<span style="color:#f92672">@</span>builder_field_setter_type <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>)) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Self {
</span></span><span style="display:flex;"><span>                    self.<span style="color:#75715e">$fname</span> <span style="color:#f92672">=</span> Some(<span style="color:#75715e">$fname</span>);
</span></span><span style="display:flex;"><span>                    self
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">build</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Result<span style="color:#f92672">&lt;</span><span style="color:#75715e">$client</span>, std::boxed::Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> std::error::Error<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>                Ok(<span style="color:#75715e">$client</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: <span style="color:#75715e">$crate</span>::builder!(<span style="color:#f92672">@</span>builder_unwrap_field self <span style="color:#75715e">$fname</span> <span style="color:#75715e">$($ftype</span>)<span style="color:#f92672">+</span>), )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span> <span style="color:#75715e">$client</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">builder</span>() -&gt; <span style="color:#75715e">$builder</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">$builder</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">$(</span> <span style="color:#75715e">$fname</span>: None, )<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>builder!(Builder -&gt; <span style="color:#a6e22e">Client</span>{
</span></span><span style="display:flex;"><span>    field: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> client <span style="color:#f92672">=</span> Client::builder().with_field(<span style="color:#66d9ef">true</span>).build().unwrap();
</span></span><span style="display:flex;"><span>    assert(client.field);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="procedural-macros">Procedural Macros</h1>
<p>With macro-by-example working, I decided to tackle proc-macros. Right now, you&rsquo;re probably like - but why? And I don&rsquo;t have a good answer to that except - why not? :) To be honest I’d been kind of wary of them, but it felt like the right time to dive in, since I already dived into the topic. I also wondered what would be the better approach. How will it be different? And I already had a pretty good use-case.</p>
<p>Proc-macros need to live in a separate crate, and they essentially take in a <code>TokenStream</code> and return another <code>TokenStream</code>, so they allow for a bit more flexibility. Here’s what a basic proc-macro looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> proc_macro::TokenStream;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">use</span> quote::quote;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[proc_macro_derive(Builder)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">builder_derive</span>(input: <span style="color:#a6e22e">TokenStream</span>) -&gt; <span style="color:#a6e22e">TokenStream</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> expanded <span style="color:#f92672">=</span> quote! {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Builder</span> {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    TokenStream::from(expanded)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, in our main crate, we could do something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> builder_option::Builder;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Builder)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Client</span> {
</span></span><span style="display:flex;"><span>    field: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this example, the <code>Builder</code> macro would generate a Builder struct for us automatically. Since we have access to the entire <code>TokenStream</code>, we can dynamically create names and fields for the <code>Builder</code> struct based on the struct being derived.</p>
<p>One neat thing about proc-macros is that we can programmatically build names based on the struct we’re deriving. For example, let’s dynamically generate the name of our builder struct by appending “Builder” to the name of the original struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">builder_derive</span>(input: <span style="color:#a6e22e">TokenStream</span>) -&gt; <span style="color:#a6e22e">TokenStream</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> parse_macro_input!(input <span style="color:#66d9ef">as</span> DeriveInput);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> input.ident;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> builder_name <span style="color:#f92672">=</span> Ident::new(<span style="color:#f92672">&amp;</span>format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">Builder&#34;</span>, name), Span::def_site());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> expanded <span style="color:#f92672">=</span> quote! {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> #builder_name {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TokenStream::from(expanded) 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To make our builder actually useful, we’ll want to populate the <code>Builder</code> struct with the same fields as the original struct, but with a twist: if a field is an <code>Option</code>, we’ll strip the <code>Option</code> to have a nice setter syntax. Here’s how we can achieve that:</p>
<pre><code>1.	First, let’s make sure the macro is only applied to structs and extract their named fields.
2.	Then, we’ll check each field’s type and strip Option if needed.
</code></pre>
<p>Here’s what that looks like in code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> fields <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> input.data {
</span></span><span style="display:flex;"><span>        Data::Struct(<span style="color:#66d9ef">ref</span> data_struct) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> data_struct.fields {
</span></span><span style="display:flex;"><span>            Fields::Named(<span style="color:#66d9ef">ref</span> fields_named) <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">&amp;</span>fields_named.named,
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> syn::Error::new_spanned(
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">&amp;</span>data_struct.fields,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;Builder can only be derived for structs with named fields&#34;</span>,
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                .to_compile_error()
</span></span><span style="display:flex;"><span>                .into();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> syn::Error::new_spanned(<span style="color:#f92672">&amp;</span>name, <span style="color:#e6db74">&#34;Builder can only be derived for structs&#34;</span>)
</span></span><span style="display:flex;"><span>                .to_compile_error()
</span></span><span style="display:flex;"><span>                .into();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">inner_type</span>(ty: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Type</span>) -&gt; (<span style="color:#66d9ef">bool</span>, <span style="color:#f92672">&amp;</span>Type) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Type::Path(type_path) <span style="color:#f92672">=</span> ty {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(segment) <span style="color:#f92672">=</span> type_path.path.segments.first() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> segment.ident <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Option&#34;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> syn::PathArguments::AngleBracketed(<span style="color:#66d9ef">ref</span> angle_bracketed) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                        segment.arguments
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(syn::GenericArgument::Type(<span style="color:#66d9ef">ref</span> inner_ty)) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                            angle_bracketed.args.first()
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">return</span> inner_ty;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ty
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> builder_fields <span style="color:#f92672">=</span> fields.iter().map(<span style="color:#f92672">|</span>f<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ident;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> ty <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ty;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> inner_ty <span style="color:#f92672">=</span> inner_type(ty);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        quote! {
</span></span><span style="display:flex;"><span>            #name: <span style="color:#a6e22e">std</span>::option::Option<span style="color:#f92672">&lt;</span>#inner_ty<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    
</span></span></code></pre></div><p>Finally, we can implement a build method on the builder, which checks each field and either takes the provided value or returns an error if a required field is missing:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[proc_macro_derive(Builder)]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// A macro to create a corresponding builder for an annotated struct
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">builder_derive</span>(input: <span style="color:#a6e22e">TokenStream</span>) -&gt; <span style="color:#a6e22e">TokenStream</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> input <span style="color:#f92672">=</span> parse_macro_input!(input <span style="color:#66d9ef">as</span> DeriveInput);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> input.ident;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> builder_name <span style="color:#f92672">=</span> Ident::new(<span style="color:#f92672">&amp;</span>format!(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">Builder&#34;</span>, name), Span::def_site());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> fields <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> input.data {
</span></span><span style="display:flex;"><span>        Data::Struct(<span style="color:#66d9ef">ref</span> data_struct) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">match</span> data_struct.fields {
</span></span><span style="display:flex;"><span>            Fields::Named(<span style="color:#66d9ef">ref</span> fields_named) <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">&amp;</span>fields_named.named,
</span></span><span style="display:flex;"><span>            _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> syn::Error::new_spanned(
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">&amp;</span>data_struct.fields,
</span></span><span style="display:flex;"><span>                    <span style="color:#e6db74">&#34;Builder can only be derived for structs with named fields&#34;</span>,
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                .to_compile_error()
</span></span><span style="display:flex;"><span>                .into();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> syn::Error::new_spanned(<span style="color:#f92672">&amp;</span>name, <span style="color:#e6db74">&#34;Builder can only be derived for structs&#34;</span>)
</span></span><span style="display:flex;"><span>                .to_compile_error()
</span></span><span style="display:flex;"><span>                .into();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">inner_type</span>(ty: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Type</span>) -&gt; (<span style="color:#66d9ef">bool</span>, <span style="color:#f92672">&amp;</span>Type) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Type::Path(type_path) <span style="color:#f92672">=</span> ty {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(segment) <span style="color:#f92672">=</span> type_path.path.segments.first() {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> segment.ident <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Option&#34;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> syn::PathArguments::AngleBracketed(<span style="color:#66d9ef">ref</span> angle_bracketed) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                        segment.arguments
</span></span><span style="display:flex;"><span>                    {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(syn::GenericArgument::Type(<span style="color:#66d9ef">ref</span> inner_ty)) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                            angle_bracketed.args.first()
</span></span><span style="display:flex;"><span>                        {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">true</span>, inner_ty);
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        (<span style="color:#66d9ef">false</span>, ty)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> builder_fields <span style="color:#f92672">=</span> fields.iter().map(<span style="color:#f92672">|</span>f<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ident;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> ty <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ty;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (_, inner_ty) <span style="color:#f92672">=</span> inner_type(ty);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        quote! {
</span></span><span style="display:flex;"><span>            #name: <span style="color:#a6e22e">std</span>::option::Option<span style="color:#f92672">&lt;</span>#inner_ty<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> builder_init <span style="color:#f92672">=</span> fields.iter().map(<span style="color:#f92672">|</span>f<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ident;
</span></span><span style="display:flex;"><span>        quote! {
</span></span><span style="display:flex;"><span>            #name: None,
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> build_fields <span style="color:#f92672">=</span> fields.iter().map(<span style="color:#f92672">|</span>f<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ident;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> ty <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ty;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> field_name_str <span style="color:#f92672">=</span> name.as_ref().unwrap().to_string();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (is_option, _) <span style="color:#f92672">=</span> inner_type(ty);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_option {
</span></span><span style="display:flex;"><span>            quote! {
</span></span><span style="display:flex;"><span>                #name: <span style="color:#a6e22e">self</span>.#name.clone(),
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            quote! {
</span></span><span style="display:flex;"><span>                #name: <span style="color:#a6e22e">self</span>.#name.clone().ok_or_else(<span style="color:#f92672">||</span> format!(<span style="color:#e6db74">&#34;Field &#39;</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39; is required&#34;</span>, #field_name_str))<span style="color:#f92672">?</span>,
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> builder_methods <span style="color:#f92672">=</span> fields.iter().map(<span style="color:#f92672">|</span>f<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ident;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> ty <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>f.ty;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> (_, inner_ty) <span style="color:#f92672">=</span> inner_type(ty);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> method_name <span style="color:#f92672">=</span> syn::Ident::new(
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">&amp;</span>format!(<span style="color:#e6db74">&#34;with_</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, name.as_ref().unwrap()),
</span></span><span style="display:flex;"><span>            Span::call_site(),
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        quote! {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> #method_name(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, #name: #inner_ty) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Self {
</span></span><span style="display:flex;"><span>                self.#name <span style="color:#f92672">=</span> std::option::Option::Some(#name);
</span></span><span style="display:flex;"><span>                self
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> expanded <span style="color:#f92672">=</span> quote! {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> #builder_name {
</span></span><span style="display:flex;"><span>             #(#builder_fields)<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span> #builder_name {
</span></span><span style="display:flex;"><span>           #(#builder_methods)<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">build</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Result<span style="color:#f92672">&lt;</span>#name, std::boxed::Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> std::error::Error<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>                Ok(#name {
</span></span><span style="display:flex;"><span>                    #(#build_fields)<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                })
</span></span><span style="display:flex;"><span>           }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">impl</span> #name {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">builder</span>() -&gt; #builder_name {
</span></span><span style="display:flex;"><span>                #builder_name {
</span></span><span style="display:flex;"><span>                    #(#builder_init)<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TokenStream::from(expanded)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This final version of our proc-macro dynamically generates a builder struct and methods for each field, handling optional fields as well. Now, we have a fully functional builder for any struct decorated with <code>#[derive(Builder)]</code>, thanks to the flexibility of proc-macros!</p>
<h1 id="packaging-both-macros">Packaging Both Macros</h1>
<p>To package both the macro-by-example and the proc-macro versions, I created two crates and made the proc-macro a dependency of the main crate, conditionally enabled by a feature flag:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml:Cargo.toml" data-lang="toml:Cargo.toml"><span style="display:flex;"><span><span style="color:#a6e22e">package</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;builder_option&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1.0&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">edition</span> = <span style="color:#e6db74">&#34;2021&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">dependencies</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">paste</span> = <span style="color:#e6db74">&#34;1.0.15&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">builder_option_derive</span> = { <span style="color:#a6e22e">version</span> = <span style="color:#e6db74">&#34;0.1.0&#34;</span>, <span style="color:#a6e22e">path</span> = <span style="color:#e6db74">&#34;../builder_option_derive&#34;</span>, <span style="color:#a6e22e">optional</span> = <span style="color:#66d9ef">true</span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#a6e22e">features</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">derive</span> = [<span style="color:#e6db74">&#34;builder_option_derive&#34;</span>]
</span></span></code></pre></div><p>In <code>lib.rs</code>, we can conditionally export the appropriate macro depending on the feature flag:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust:lib.rs" data-lang="rust:lib.rs"><span style="display:flex;"><span><span style="color:#75715e">#[cfg(not(feature = </span><span style="color:#e6db74">&#34;derive&#34;</span><span style="color:#75715e">))]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[macro_export]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// Macro to declare a struct and a corresponding builder.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span>macro_rules<span style="color:#f92672">!</span> builder {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[cfg(feature = </span><span style="color:#e6db74">&#34;derive&#34;</span><span style="color:#75715e">)]</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">/// re-export the `Builder` macro from `builder_option_derive` here if a `derive` feature is enabled
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">use</span> builder_option_derive::Builder;
</span></span></code></pre></div><p>This setup allows us to use both types of macros seamlessly: users can either use the macro-by-example builder pattern directly or enable the <code>derive</code> feature to access the proc-macro.</p>
<h1 id="wrapping-up">Wrapping Up</h1>
<p>There are still a few advanced concepts I haven’t fully grasped, like all of the intricacies of <a href="https://crates.io/crates/builder_macro">builder_macro</a>, but I’m now far more comfortable diving into Rust’s macro system. The journey through both macro-by-example and proc-macro approaches was challenging, but the flexibility and power of Rust macros are impressive once you get the hang of it.</p>
<p>I hope this helps someone who’s just starting out with Rust macros or needs to generate some repetitive code more elegantly. Happy coding, and remember: sometimes the macro rabbit hole is worth it!</p>


                
            </div>
        </section>
        <script>
              
                        (function addTitleToCodeBlock() {
  let list = document.body.getElementsByClassName("highlight");

  for (i = 0; i <= list.length - 1; i++) {
    let code = list[i].firstElementChild.firstElementChild;
    let codeName = code ? code.className.split(":")[1] : null;

    if (codeName) {
                console.log(codeName)
      let div = document.createElement("div");
      div.textContent = codeName;
      div.classList.add("code-name");
      code.parentNode.insertBefore(div, code);
    }
  }
})();

        </script>

        <footer class="fs-6 text-muted mt-5">
            <p>
                CC0. Powered by <a href="https://gohugo.io">Hugo</a>. Theme inspired by <a href="https://www.mattdesl.com/">@mattdesl</a> and <a href="https://ozafoto.com/digital/">Oza</a>.
            </p>
        </footer>
    </div>
  </body>
</html>
