{"pageProps":{"_nextI18Next":{"initialI18nStore":{"en":{"common":{"back-to-home":"Back to home","error-with-status":"A {{statusCode}} error occurred on server","error-without-status":"An error occurred on the server","h1":"A simple example","to-second-page":"To second page"},"blog":{"title":"Blog @unjello"},"comments":{"header":"Comments","discussion_is_at":"The actual discussion is happening on ","welcome":"Come over, don't be shy!","error":"Something went wrong with fetching the comments."},"header":{"he":"he","him":"him","activist":"activist","trees_lover":"trees and greenery lover"},"footer":{"powered_by":"Powered by","inspired_by":"Theme inspired by","and":"and"}}},"initialLocale":"en","ns":["common","blog","comments","header","footer"],"userConfig":{"debug":false,"i18n":{"defaultLocale":"en","locales":["en"]},"reloadOnPrerender":false,"default":{"debug":false,"i18n":{"defaultLocale":"en","locales":["en"]},"reloadOnPrerender":false}}},"posts":{"index":{"id":"index","content":"<p>Random things the voices in my head told me to write down.</p>","title":"Blog","date":"","card":"","url":"","type":"","where":"","rank":"","mastodonId":""},"items":[{"id":"rust_github_2023","content":"<div class=\"paragraph\">\n<div class=\"title\">Falling in Love with SourceHut, But Still Tempted by GitHub Actions</div>\n<p><a href=\"https://git.sr.ht/\">SourceHut</a> has recently won my heart with its simplicity and 90&#8217;s UI vibe, but I can&#8217;t resist the appeal of GitHub&#8217;s free workflow automation platform. I&#8217;ve been working on a few small projects in Python, TypeScript, and Rust, and have set up CI for all of them. Now that I&#8217;ve revived my blog, I thought I&#8217;d write about my experience using GitHub Actions for deployment.</p>\n</div>\n<div class=\"paragraph\">\n<p>I use GitHub Actions to deploy my Static Site Generated site to GitHub Pages or upload packages to various registries (pypi, npm, crates). I then added the Continuous Development part with testing, linting, and so on. In my day job, I always advocate for activities like this to be as close to the developer as possible - ideally as a commit pre-hook. I&#8217;ve followed this principle in my own projects, but to make sure I was getting the most out of GitHub Actions, I also added testing on all platforms I wanted to support but didn&#8217;t have easy access to. Lastly, I decided to hit the \"fund\" button - who knows, maybe it&#8217;ll be my ticket to an early retirement! :)</p>\n</div>\n<div class=\"paragraph\">\n<div class=\"title\">Setting up a Pre-Commit Hook</div>\n<p>The first step to creating a smooth workflow is to set up a pre-commit hook. This helps to ensure that code is well-formatted and free of errors before it&#8217;s pushed to the remote repository. To make this happen, I use <a href=\"https://pre-commit.com\">pre-commit</a>. It&#8217;s an amazing tool that works across different programming languages and makes it easy to run checks locally.</p>\n</div>\n<div class=\"paragraph\">\n<p>Getting started is pretty simple, just follow the installation instructions on the pre-commit website. Then, you&#8217;ll need to define the validation rules for your project. Here&#8217;s an example of the rules I use for Rust projects:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">repos:\n  -   repo: https://github.com/pre-commit/pre-commit-hooks\n      rev: v4.4.0\n      hooks:\n        -   id: fix-byte-order-marker\n        -   id: check-case-conflict\n        -   id: check-merge-conflict\n        -   id: check-symlinks\n        -   id: check-yaml\n        -   id: check-toml\n        -   id: end-of-file-fixer\n        -   id: mixed-line-ending\n            args: [--fix=lf]\n        -   id: trailing-whitespace\n  -   repo: https://github.com/doublify/pre-commit-rust\n      rev: master\n      hooks:\n        -   id: fmt\n            args: [\"--verbose\", \"--\"]\n        -   id: cargo-check\n        -   id: clippy</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Next, install the rules with the pre-commit install command. This will set up the .git/hooks/pre-commit file for you. Keep in mind that this file is not synced to the remote repository, so each developer will need to run the setup locally. To make this easier, I like to create a file with useful commands using a tool called <a href=\"https://github.com/casey/just\">just</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>With the following <code>Justfile</code>, you can run <code>just install</code> to create the hooks and <code>just prehook</code> to run checks on demand:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-makefile hljs\" data-lang=\"makefile\">configure:\n\tpre-commit install\n\nprecommit:\n\tpre-commit run --all-files</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<div class=\"title\">Triggering Your Workflow</div>\n<p>The next step in setting up your workflow is to determine when it should run. I usually use just a couple of triggers.</p>\n</div>\n<div class=\"paragraph\">\n<p>For everyday Continuous Integration, I set it up to run on every push or pull request:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">on: [push, pull_request]</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If I have some expensive tests that take a long time to run, I&#8217;ll schedule them to run nightly:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">on:\n  schedule:\n    - cron: \"0 0 * * *\"</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>For libraries or websites - anything that gets published - I have a separate workflow that&#8217;s triggered by gh release create:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">on:\n  release:\n    types: [created]</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<div class=\"title\">Defining your testing strategy matrix</div>\n<p>When it comes to testing on different platforms, I love using GitHub Actions. It&#8217;s super easy to use and just works for me. Sure, some people may have had issues with the stability of GitHub&#8217;s workers, but I haven&#8217;t had any problems yet. I&#8217;m not doing any heavy compiling, so I might just be lucky.</p>\n</div>\n<div class=\"paragraph\">\n<p>To test on different platforms, we&#8217;ll be using something called a <a href=\"https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs\">strategy matrix</a>. There are a few ways to define this matrix, like providing separate lists of OS types and hardware architectures and letting GitHub calculate all the possibilities. But, I usually just keep it simple and go for a list of 64-bit Windows, 64-bit Linux, and both Intel and ARM macOS.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">jobs:\n  dist:\n    strategy:\n      matrix:\n        include:\n          - os: windows-latest\n            target: x86_64-pc-windows-msvc\n            code-target: win32-x64\n          - os: windows-latest\n            target: aarch64-pc-windows-msvc\n            code-target: win32-arm64\n          - os: ubuntu-20.04\n            target: x86_64-unknown-linux-gnu\n            code-target: linux-x64\n            container: ubuntu:18.04\n          - os: macos-11\n            target: x86_64-apple-darwin\n            code-target: darwin-x64\n          - os: macos-11\n            target: aarch64-apple-darwin\n            code-target: darwin-arm64</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<div class=\"title\">Running validation</div>\n<p>If you&#8217;ve been following along, now it&#8217;s time to actually run the validation checks on our code. But first, for our Ubuntu workflow, you&#8217;ll need to install some build tools first:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">if: contains(matrix.os, 'ubuntu')\nrun: apt-get update &amp;&amp; apt-get install -y curl build-essential gcc g++</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Now, for the actual validation, we&#8217;ll be using GitHub Actions. Actions are packages in JavaScript or TypeScript format, and we&#8217;ll be using the official <a href=\"https://github.com/actions/checkout\">actions/checkout</a> to checkout our code. This action is provided by GitHub and is the recommended way to do this.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">uses: actions/checkout@v3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Next, we&#8217;ll use the <a href=\"https://github.com/actions-rs\">action-rs</a> package to handle everything we need for our continuous integration pipeline: installing the toolchain, running formatting checks, clippy checks, and tests. This is how my <code>.github/workflows/ci.yaml</code> looks like:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">on: [push, pull_request]\n\nname: CI\n\njobs:\n  dist:\n    strategy:\n      matrix:\n        include:\n          - os: windows-latest\n            target: x86_64-pc-windows-msvc\n            code-target: win32-x64\n          - os: windows-latest\n            target: aarch64-pc-windows-msvc\n            code-target: win32-arm64\n          - os: ubuntu-20.04\n            target: x86_64-unknown-linux-gnu\n            code-target: linux-x64\n            container: ubuntu:18.04\n          - os: macos-11\n            target: x86_64-apple-darwin\n            code-target: darwin-x64\n          - os: macos-11\n            target: aarch64-apple-darwin\n            code-target: darwin-arm64\n\n    name: dist (${{ matrix.target }})\n    runs-on: ${{ matrix.os }}\n    container: ${{ matrix.container }}\n\n    steps:\n      - name: Install prerequisites\n        if: contains(matrix.os, 'ubuntu')\n        run: apt-get update &amp;&amp; apt-get install -y curl build-essential gcc g++\n\n      - name: Checkout sources\n        uses: actions/checkout@v3\n\n      - name: Install Rust toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          profile: minimal\n          toolchain: stable\n          override: true\n          target: ${{ matrix.target }}\n          components: rustfmt, clippy, rust-src\n\n      - name: Run cargo check\n        uses: actions-rs/cargo@v1\n        with:\n          command: check\n\n      - name: Run cargo test\n        uses: actions-rs/cargo@v1\n        with:\n          command: test\n\n      - name: Run cargo fmt\n        uses: actions-rs/cargo@v1\n        with:\n          command: fmt\n          args: --all -- --check\n\n      - name: Run cargo clippy\n        uses: actions-rs/cargo@v1\n        with:\n          command: clippy\n          args: -- -D warnings</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<div class=\"title\">Publishing to Crates.io</div>\n<p>To have a complete publishing pipeline, we need to create an API token. You can do this by going to the <a href=\"https://crates.io/settings/tokens\">API Tokens</a> page on <a href=\"https://crates.io/\">crates.io</a> and creating a new token. After that, go to your repository&#8217;s <code>Settings &gt; Secrets and variables &gt; Actions</code> and create a new repository secret, so that the token is visible to the actions without being exposed publicly. I typically name it <code>CRATES_TOKEN</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>There are a few ways to publish packages, but I prefer to create both a <strong>tag</strong> and a <strong>release</strong>. First, I create a separate pipeline that is triggered by creating a release.</p>\n</div>\n<div class=\"paragraph\">\n<p>The YAML code looks like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-yaml hljs\" data-lang=\"yaml\">name: Publish Package to crates.io\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    name: Publish\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout sources\n        uses: actions/checkout@v3\n\n      - name: Install stable toolchain\n        uses: actions-rs/toolchain@v1\n        with:\n          profile: minimal\n          toolchain: stable\n          override: true\n\n      - run: cargo publish --token ${CRATES_TOKEN}\n        env:\n          CRATES_TOKEN: ${{ secrets.CRATES_TOKEN }}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>There are multiple ways to create a release, including using GitHub&#8217;s REST API, but I prefer to use the command line:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlightjs highlight\"><code class=\"language-sh hljs\" data-lang=\"sh\">$ git tag -a v0.1.0 -m \"Tagging v0.1.0\"\n$ gh release create v0.1.0 -t \"Release v0.1.0\"</code></pre>\n</div>\n</div>","title":"Rocking Rust, Git, and GitHub in 2023 Like a Pro","date":"2023-02-11T10:58:00.000Z","card":"","url":"","type":"","where":"","rank":"","mastodonId":"120321"},{"id":"same_old_story","content":"<p><img src=\"/casablanca.jpg\" alt=\"Dooley Wilson, Ingrid Bergman and Humphrey Bogart in a frame from Hollywood&#x27;s classic: Cassablanca\"></p>\n<p>I don't think I even remember anymore, how many times I have restarted the blog. Last time I wrote something useful, was probably around 2008.</p>\n<p>I still have the old sites backed up somewhere. At least few of them. Unfortunately they're not very useful, mostly because they have been using blogging engines -- either Wordpress-like, or my own -- and while I backed up the code, I did not export anything from the database, leaving myself with just the looks, and no content.</p>\n<p>In 2017 I have discovered <a href=\"https://gohugo.io/\">Static Site Generators</a>, and it changed my approach completely. Primarily, because engines, blogging engines, and Wordpress above anything else, are just one big <a href=\"https://en.wikipedia.org/wiki/Honeypot_(computing)\">honeypots</a>. The fact that I didn't have to spin up any MySQL instance and therefore hosting costs dropped to big fat zero, after introduction of <a href=\"https://pages.github.com\">GitHub Pages</a> was a big plus, but the biggest benefit of them all is the fact, that I have a full, working and accessible copy of my blog. If only I continued to write :)</p>\n<p>I hope, this time will truly be better :)</p>","title":"It's still the same old story","date":"2023-02-07T15:28:00.000Z","card":"","url":"","type":"","where":"","rank":"","mastodonId":"109825295757896454"},{"id":"reboot","content":"<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">% </span><span class=\"bash\">/sbin/shutdown -r now</span></code></pre>\n<p>It begins to strike me, that I may not be good at blogging. Let's see if I can make it this time.</p>","title":"One more time?","date":"2021-06-26T08:35:00.000Z","card":"","url":"","type":"","where":"","rank":"","mastodonId":""},{"id":"initial-revision","content":"<pre><code class=\"hljs language-shell\"><span class=\"hljs-meta prompt_\">% </span><span class=\"bash\">letter</span>\r\nletter: Command not found.\r<span class=\"hljs-meta prompt_\">\n% </span><span class=\"bash\">mail</span>\r\nTo: ^X ^F ^C\r<span class=\"hljs-meta prompt_\">\n% </span><span class=\"bash\"><span class=\"hljs-built_in\">help</span> mail</span>\r\nhelp: Command not found.\r<span class=\"hljs-meta prompt_\">\n% </span><span class=\"bash\">damn!</span>\r\n!: Event unrecognized\r<span class=\"hljs-meta prompt_\">\n% </span><span class=\"bash\"><span class=\"hljs-built_in\">logout</span></span></code></pre>\n<p>It's been sort of a tradition, to begin each incarnation of my blog, with a quote from this old joke<sup><a href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref aria-describedby=\"footnote-label\">1</a></sup>. If one can trust <em>the, uh, Internets</em>, this blog was esentially down since 2007. A decade! Enough is enough. Time to get back.</p>\n<section data-footnotes class=\"footnotes\"><h2 class=\"sr-only\" id=\"footnote-label\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-1\">\n<p><a href=\"https://gist.github.com/D3MZ/3915286\">https://gist.github.com/D3MZ/3915286</a> <a href=\"#user-content-fnref-1\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n</ol>\n</section>","title":"Initial Revision","date":"2017-11-05T09:44:44.000Z","card":"","url":"","type":"","where":"","rank":"","mastodonId":""}]}},"__N_SSG":true}